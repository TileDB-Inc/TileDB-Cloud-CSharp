/*
 * TileDB Storage Platform API
 *
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = TileDB.Cloud.Rest.Client.OpenAPIDateConverter;

namespace TileDB.Cloud.Rest.Model
{
    /// <summary>
    /// User-defined function
    /// </summary>
    [DataContract]
    public partial class MultiArrayUDF :  IEquatable<MultiArrayUDF>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets Language
        /// </summary>
        [DataMember(Name="language", EmitDefaultValue=false)]
        public UDFLanguage? Language { get; set; }
        /// <summary>
        /// Gets or Sets ResultFormat
        /// </summary>
        [DataMember(Name="result_format", EmitDefaultValue=false)]
        public ResultFormat? ResultFormat { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="MultiArrayUDF" /> class.
        /// </summary>
        /// <param name="udfInfoName">name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec.</param>
        /// <param name="language">language.</param>
        /// <param name="version">Type-specific version.</param>
        /// <param name="imageName">Docker image name to use for UDF.</param>
        /// <param name="resourceClass">The resource class to use for the UDF execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the UDF will execute in the standard resource class of the TileDB Cloud provider. .</param>
        /// <param name="exec">Type-specific executable text.</param>
        /// <param name="execRaw">optional raw text to store of serialized function, used for showing in UI.</param>
        /// <param name="resultFormat">resultFormat.</param>
        /// <param name="taskName">name of task, optional.</param>
        /// <param name="argument">Deprecated: Prefer to use &#x60;argument_json&#x60; instead. Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format .</param>
        /// <param name="argumentsJson">A series of key-value pairs to be passed as arguments into the UDF. See &#x60;TGUDFNodeData.arguments&#x60; for more information. If this format is used to pass arguments, arrays will be passed into the UDF as specified by the Node placeholders passed in here, rather than the classic method of putting all array arguments in the first parameter. Either this or &#x60;argument&#x60; should be set. .</param>
        /// <param name="storedParamUuids">The UUIDs of stored input parameters (passed in a language-specific format within \&quot;argument\&quot;) to be retrieved from the server-side cache. Serialized in standard hex format with no {}..</param>
        /// <param name="storeResults">store results for later retrieval.</param>
        /// <param name="dontDownloadResults">Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\&quot;yes download results\&quot;)..</param>
        /// <param name="ranges">ranges.</param>
        /// <param name="subarray">subarray.</param>
        /// <param name="buffers">List of buffers to fetch (attributes + dimensions). Deprecated; please set arrays with &#x60;UDFArrayDetails&#x60;..</param>
        /// <param name="arrays">Array ranges/buffer into to run UDF on.</param>
        /// <param name="timeout">UDF-type timeout in seconds (default: 900).</param>
        /// <param name="taskGraphUuid">If set, the ID of the log for the task graph that this was part of. .</param>
        /// <param name="clientNodeUuid">If set, the client-defined ID of the node within this task&#39;s graph. .</param>
        public MultiArrayUDF(string udfInfoName = default(string), UDFLanguage? language = default(UDFLanguage?), string version = default(string), string imageName = default(string), string resourceClass = default(string), string exec = default(string), string execRaw = default(string), ResultFormat? resultFormat = default(ResultFormat?), string taskName = default(string), string argument = default(string), List<TGUDFArgument> argumentsJson = default(List<TGUDFArgument>), List<string> storedParamUuids = default(List<string>), bool storeResults = default(bool), bool dontDownloadResults = default(bool), QueryRanges ranges = default(QueryRanges), UDFSubarray subarray = default(UDFSubarray), List<string> buffers = default(List<string>), List<UDFArrayDetails> arrays = default(List<UDFArrayDetails>), int timeout = default(int), string taskGraphUuid = default(string), string clientNodeUuid = default(string))
        {
            this.ArgumentsJson = argumentsJson;
            this.UdfInfoName = udfInfoName;
            this.Language = language;
            this._Version = version;
            this.ImageName = imageName;
            this.ResourceClass = resourceClass;
            this.Exec = exec;
            this.ExecRaw = execRaw;
            this.ResultFormat = resultFormat;
            this.TaskName = taskName;
            this.Argument = argument;
            this.ArgumentsJson = argumentsJson;
            this.StoredParamUuids = storedParamUuids;
            this.StoreResults = storeResults;
            this.DontDownloadResults = dontDownloadResults;
            this.Ranges = ranges;
            this.Subarray = subarray;
            this.Buffers = buffers;
            this.Arrays = arrays;
            this.Timeout = timeout;
            this.TaskGraphUuid = taskGraphUuid;
            this.ClientNodeUuid = clientNodeUuid;
        }

        /// <summary>
        /// name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec
        /// </summary>
        /// <value>name of UDFInfo to run, format is {namespace}/{udf_name}. Can not be used with exec</value>
        [DataMember(Name="udf_info_name", EmitDefaultValue=false)]
        public string UdfInfoName { get; set; }


        /// <summary>
        /// Type-specific version
        /// </summary>
        /// <value>Type-specific version</value>
        [DataMember(Name="version", EmitDefaultValue=false)]
        public string _Version { get; set; }

        /// <summary>
        /// Docker image name to use for UDF
        /// </summary>
        /// <value>Docker image name to use for UDF</value>
        [DataMember(Name="image_name", EmitDefaultValue=false)]
        public string ImageName { get; set; }

        /// <summary>
        /// The resource class to use for the UDF execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the UDF will execute in the standard resource class of the TileDB Cloud provider. 
        /// </summary>
        /// <value>The resource class to use for the UDF execution. Resource classes define resource limits for memory and CPUs. If this is empty, then the UDF will execute in the standard resource class of the TileDB Cloud provider. </value>
        [DataMember(Name="resource_class", EmitDefaultValue=false)]
        public string ResourceClass { get; set; }

        /// <summary>
        /// Type-specific executable text
        /// </summary>
        /// <value>Type-specific executable text</value>
        [DataMember(Name="exec", EmitDefaultValue=false)]
        public string Exec { get; set; }

        /// <summary>
        /// optional raw text to store of serialized function, used for showing in UI
        /// </summary>
        /// <value>optional raw text to store of serialized function, used for showing in UI</value>
        [DataMember(Name="exec_raw", EmitDefaultValue=false)]
        public string ExecRaw { get; set; }


        /// <summary>
        /// name of task, optional
        /// </summary>
        /// <value>name of task, optional</value>
        [DataMember(Name="task_name", EmitDefaultValue=false)]
        public string TaskName { get; set; }

        /// <summary>
        /// Deprecated: Prefer to use &#x60;argument_json&#x60; instead. Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format 
        /// </summary>
        /// <value>Deprecated: Prefer to use &#x60;argument_json&#x60; instead. Argument(s) to pass to UDF function, tuple or list of args/kwargs which can be in native or JSON format </value>
        [DataMember(Name="argument", EmitDefaultValue=false)]
        public string Argument { get; set; }

        /// <summary>
        /// A series of key-value pairs to be passed as arguments into the UDF. See &#x60;TGUDFNodeData.arguments&#x60; for more information. If this format is used to pass arguments, arrays will be passed into the UDF as specified by the Node placeholders passed in here, rather than the classic method of putting all array arguments in the first parameter. Either this or &#x60;argument&#x60; should be set. 
        /// </summary>
        /// <value>A series of key-value pairs to be passed as arguments into the UDF. See &#x60;TGUDFNodeData.arguments&#x60; for more information. If this format is used to pass arguments, arrays will be passed into the UDF as specified by the Node placeholders passed in here, rather than the classic method of putting all array arguments in the first parameter. Either this or &#x60;argument&#x60; should be set. </value>
        [DataMember(Name="arguments_json", EmitDefaultValue=true)]
        public List<TGUDFArgument> ArgumentsJson { get; set; }

        /// <summary>
        /// The UUIDs of stored input parameters (passed in a language-specific format within \&quot;argument\&quot;) to be retrieved from the server-side cache. Serialized in standard hex format with no {}.
        /// </summary>
        /// <value>The UUIDs of stored input parameters (passed in a language-specific format within \&quot;argument\&quot;) to be retrieved from the server-side cache. Serialized in standard hex format with no {}.</value>
        [DataMember(Name="stored_param_uuids", EmitDefaultValue=false)]
        public List<string> StoredParamUuids { get; set; }

        /// <summary>
        /// store results for later retrieval
        /// </summary>
        /// <value>store results for later retrieval</value>
        [DataMember(Name="store_results", EmitDefaultValue=false)]
        public bool StoreResults { get; set; }

        /// <summary>
        /// Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\&quot;yes download results\&quot;).
        /// </summary>
        /// <value>Set to true to avoid downloading the results of this UDF. Useful for intermediate nodes in a task graph where you will not be using the results of your function. Defaults to false (\&quot;yes download results\&quot;).</value>
        [DataMember(Name="dont_download_results", EmitDefaultValue=false)]
        public bool DontDownloadResults { get; set; }

        /// <summary>
        /// Gets or Sets Ranges
        /// </summary>
        [DataMember(Name="ranges", EmitDefaultValue=false)]
        public QueryRanges Ranges { get; set; }

        /// <summary>
        /// Gets or Sets Subarray
        /// </summary>
        [DataMember(Name="subarray", EmitDefaultValue=false)]
        public UDFSubarray Subarray { get; set; }

        /// <summary>
        /// List of buffers to fetch (attributes + dimensions). Deprecated; please set arrays with &#x60;UDFArrayDetails&#x60;.
        /// </summary>
        /// <value>List of buffers to fetch (attributes + dimensions). Deprecated; please set arrays with &#x60;UDFArrayDetails&#x60;.</value>
        [DataMember(Name="buffers", EmitDefaultValue=false)]
        public List<string> Buffers { get; set; }

        /// <summary>
        /// Array ranges/buffer into to run UDF on
        /// </summary>
        /// <value>Array ranges/buffer into to run UDF on</value>
        [DataMember(Name="arrays", EmitDefaultValue=false)]
        public List<UDFArrayDetails> Arrays { get; set; }

        /// <summary>
        /// UDF-type timeout in seconds (default: 900)
        /// </summary>
        /// <value>UDF-type timeout in seconds (default: 900)</value>
        [DataMember(Name="timeout", EmitDefaultValue=false)]
        public int Timeout { get; set; }

        /// <summary>
        /// If set, the ID of the log for the task graph that this was part of. 
        /// </summary>
        /// <value>If set, the ID of the log for the task graph that this was part of. </value>
        [DataMember(Name="task_graph_uuid", EmitDefaultValue=false)]
        public string TaskGraphUuid { get; set; }

        /// <summary>
        /// If set, the client-defined ID of the node within this task&#39;s graph. 
        /// </summary>
        /// <value>If set, the client-defined ID of the node within this task&#39;s graph. </value>
        [DataMember(Name="client_node_uuid", EmitDefaultValue=false)]
        public string ClientNodeUuid { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MultiArrayUDF {\n");
            sb.Append("  UdfInfoName: ").Append(UdfInfoName).Append("\n");
            sb.Append("  Language: ").Append(Language).Append("\n");
            sb.Append("  _Version: ").Append(_Version).Append("\n");
            sb.Append("  ImageName: ").Append(ImageName).Append("\n");
            sb.Append("  ResourceClass: ").Append(ResourceClass).Append("\n");
            sb.Append("  Exec: ").Append(Exec).Append("\n");
            sb.Append("  ExecRaw: ").Append(ExecRaw).Append("\n");
            sb.Append("  ResultFormat: ").Append(ResultFormat).Append("\n");
            sb.Append("  TaskName: ").Append(TaskName).Append("\n");
            sb.Append("  Argument: ").Append(Argument).Append("\n");
            sb.Append("  ArgumentsJson: ").Append(ArgumentsJson).Append("\n");
            sb.Append("  StoredParamUuids: ").Append(StoredParamUuids).Append("\n");
            sb.Append("  StoreResults: ").Append(StoreResults).Append("\n");
            sb.Append("  DontDownloadResults: ").Append(DontDownloadResults).Append("\n");
            sb.Append("  Ranges: ").Append(Ranges).Append("\n");
            sb.Append("  Subarray: ").Append(Subarray).Append("\n");
            sb.Append("  Buffers: ").Append(Buffers).Append("\n");
            sb.Append("  Arrays: ").Append(Arrays).Append("\n");
            sb.Append("  Timeout: ").Append(Timeout).Append("\n");
            sb.Append("  TaskGraphUuid: ").Append(TaskGraphUuid).Append("\n");
            sb.Append("  ClientNodeUuid: ").Append(ClientNodeUuid).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MultiArrayUDF);
        }

        /// <summary>
        /// Returns true if MultiArrayUDF instances are equal
        /// </summary>
        /// <param name="input">Instance of MultiArrayUDF to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MultiArrayUDF input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.UdfInfoName == input.UdfInfoName ||
                    (this.UdfInfoName != null &&
                    this.UdfInfoName.Equals(input.UdfInfoName))
                ) && 
                (
                    this.Language == input.Language ||
                    (this.Language != null &&
                    this.Language.Equals(input.Language))
                ) && 
                (
                    this._Version == input._Version ||
                    (this._Version != null &&
                    this._Version.Equals(input._Version))
                ) && 
                (
                    this.ImageName == input.ImageName ||
                    (this.ImageName != null &&
                    this.ImageName.Equals(input.ImageName))
                ) && 
                (
                    this.ResourceClass == input.ResourceClass ||
                    (this.ResourceClass != null &&
                    this.ResourceClass.Equals(input.ResourceClass))
                ) && 
                (
                    this.Exec == input.Exec ||
                    (this.Exec != null &&
                    this.Exec.Equals(input.Exec))
                ) && 
                (
                    this.ExecRaw == input.ExecRaw ||
                    (this.ExecRaw != null &&
                    this.ExecRaw.Equals(input.ExecRaw))
                ) && 
                (
                    this.ResultFormat == input.ResultFormat ||
                    (this.ResultFormat != null &&
                    this.ResultFormat.Equals(input.ResultFormat))
                ) && 
                (
                    this.TaskName == input.TaskName ||
                    (this.TaskName != null &&
                    this.TaskName.Equals(input.TaskName))
                ) && 
                (
                    this.Argument == input.Argument ||
                    (this.Argument != null &&
                    this.Argument.Equals(input.Argument))
                ) && 
                (
                    this.ArgumentsJson == input.ArgumentsJson ||
                    this.ArgumentsJson != null &&
                    input.ArgumentsJson != null &&
                    this.ArgumentsJson.SequenceEqual(input.ArgumentsJson)
                ) && 
                (
                    this.StoredParamUuids == input.StoredParamUuids ||
                    this.StoredParamUuids != null &&
                    input.StoredParamUuids != null &&
                    this.StoredParamUuids.SequenceEqual(input.StoredParamUuids)
                ) && 
                (
                    this.StoreResults == input.StoreResults ||
                    (this.StoreResults != null &&
                    this.StoreResults.Equals(input.StoreResults))
                ) && 
                (
                    this.DontDownloadResults == input.DontDownloadResults ||
                    (this.DontDownloadResults != null &&
                    this.DontDownloadResults.Equals(input.DontDownloadResults))
                ) && 
                (
                    this.Ranges == input.Ranges ||
                    (this.Ranges != null &&
                    this.Ranges.Equals(input.Ranges))
                ) && 
                (
                    this.Subarray == input.Subarray ||
                    (this.Subarray != null &&
                    this.Subarray.Equals(input.Subarray))
                ) && 
                (
                    this.Buffers == input.Buffers ||
                    this.Buffers != null &&
                    input.Buffers != null &&
                    this.Buffers.SequenceEqual(input.Buffers)
                ) && 
                (
                    this.Arrays == input.Arrays ||
                    this.Arrays != null &&
                    input.Arrays != null &&
                    this.Arrays.SequenceEqual(input.Arrays)
                ) && 
                (
                    this.Timeout == input.Timeout ||
                    (this.Timeout != null &&
                    this.Timeout.Equals(input.Timeout))
                ) && 
                (
                    this.TaskGraphUuid == input.TaskGraphUuid ||
                    (this.TaskGraphUuid != null &&
                    this.TaskGraphUuid.Equals(input.TaskGraphUuid))
                ) && 
                (
                    this.ClientNodeUuid == input.ClientNodeUuid ||
                    (this.ClientNodeUuid != null &&
                    this.ClientNodeUuid.Equals(input.ClientNodeUuid))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.UdfInfoName != null)
                    hashCode = hashCode * 59 + this.UdfInfoName.GetHashCode();
                if (this.Language != null)
                    hashCode = hashCode * 59 + this.Language.GetHashCode();
                if (this._Version != null)
                    hashCode = hashCode * 59 + this._Version.GetHashCode();
                if (this.ImageName != null)
                    hashCode = hashCode * 59 + this.ImageName.GetHashCode();
                if (this.ResourceClass != null)
                    hashCode = hashCode * 59 + this.ResourceClass.GetHashCode();
                if (this.Exec != null)
                    hashCode = hashCode * 59 + this.Exec.GetHashCode();
                if (this.ExecRaw != null)
                    hashCode = hashCode * 59 + this.ExecRaw.GetHashCode();
                if (this.ResultFormat != null)
                    hashCode = hashCode * 59 + this.ResultFormat.GetHashCode();
                if (this.TaskName != null)
                    hashCode = hashCode * 59 + this.TaskName.GetHashCode();
                if (this.Argument != null)
                    hashCode = hashCode * 59 + this.Argument.GetHashCode();
                if (this.ArgumentsJson != null)
                    hashCode = hashCode * 59 + this.ArgumentsJson.GetHashCode();
                if (this.StoredParamUuids != null)
                    hashCode = hashCode * 59 + this.StoredParamUuids.GetHashCode();
                if (this.StoreResults != null)
                    hashCode = hashCode * 59 + this.StoreResults.GetHashCode();
                if (this.DontDownloadResults != null)
                    hashCode = hashCode * 59 + this.DontDownloadResults.GetHashCode();
                if (this.Ranges != null)
                    hashCode = hashCode * 59 + this.Ranges.GetHashCode();
                if (this.Subarray != null)
                    hashCode = hashCode * 59 + this.Subarray.GetHashCode();
                if (this.Buffers != null)
                    hashCode = hashCode * 59 + this.Buffers.GetHashCode();
                if (this.Arrays != null)
                    hashCode = hashCode * 59 + this.Arrays.GetHashCode();
                if (this.Timeout != null)
                    hashCode = hashCode * 59 + this.Timeout.GetHashCode();
                if (this.TaskGraphUuid != null)
                    hashCode = hashCode * 59 + this.TaskGraphUuid.GetHashCode();
                if (this.ClientNodeUuid != null)
                    hashCode = hashCode * 59 + this.ClientNodeUuid.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
